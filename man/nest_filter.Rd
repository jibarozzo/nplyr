% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nest_filter.R
\name{nest_filter}
\alias{nest_filter}
\title{Subset rows in a nested data frame using column values.}
\usage{
nest_filter(.data, .nest_data, ..., .preserve = FALSE)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble) or a lazy
data frame (e.g. from dbplyr or dtplyr).}

\item{.nest_data}{A list-col containing data frames (or tibbles).}

\item{...}{\verb{<data-masking>} Expressions that return a logical value and are
defined in terms of the variables in \code{.data}. If multiple expressions are
included, they are combined with the \code{&} operator. Only rows for which all
conditions are \code{TRUE} are kept. Columns to filter by must be present in all
nested tibbles in \code{.nest_data}.}

\item{.preserve}{Relevant when the \code{.nest_data} input is grouped. If
\code{.preserve = FALSE} (the default), the grouping structure is recalculated
based on the resulting data, otherwise the grouping is kept as is.}
}
\value{
A tibble or dataframe with nested objects of the same type as \code{.nest_data}.
The output in \code{.nest_data} has the following properties:
\itemize{
\item Rows are a subset of the input, but appear in the same order.
\item Columns are not modified.
\item The number of groups may be reduced (if \code{.preserved} is not \code{TRUE}).
\item Data frame attributes are preserved.
}
}
\description{
\code{nest_filter()} is used to subset a nested data frame, retaining all the rows
that satisfy your conditions. To be retained, the row must produce a value of
\code{TRUE} for all conditions. Note that when a condition evaluates to \code{NA} the
row will be dropped, unlike base subsetting with \code{[}.

This function is largely a wrapper around its \code{dplyr} counterpart - for more
information, please consult the documentation for \code{dplyr::filter()}.
}
\details{
The \code{nest_filter()} function is used to subset the rows of each of the objects
of \code{.nest_data}, applying the expressions in \code{...} to the column values to
determine which rows should be retained. It can be applied to both grouped and
ungrouped data (see \code{\link[=nest_group_by]{nest_group_by()}} and \code{\link[=nest_ungroup]{nest_ungroup()}}). However, the
underlying filter operation from dplyr is not yet smart enough to optimise the
filtering operation on grouped datasets that do not need grouped calculations.
For this reason, filtering is often considerably faster on ungrouped data.
}
\section{Useful filter functions}{


There are many functions and operators that are useful when constructing the
expressions used to filter the data:
\itemize{
\item \code{\link{==}}, \code{\link{>}}, \code{\link{>=}}, etc.
\item \code{\link{&}}, \code{\link{|}}, \code{\link{!}}, \code{\link[=xor]{xor()}}
\item \code{\link[=is.na]{is.na()}}
\item \code{\link[dplyr:between]{dplyr::between()}}, \code{\link[dplyr:near]{dplyr::near()}}
}
}

\section{Grouped tibbles}{


Because filtering expressions are computed within groups, they may yield
different results on grouped tibbles. This will be the case as soon as an
aggregating, lagging, or ranking function is involved. Compare this ungrouped
filtering:\preformatted{gapminder \%>\% 
  nest(data = -continent) \%>\% 
  nest_filter(data, pop > mean(pop, na.rm = TRUE))
}

With the grouped equivalent:\preformatted{gapminder \%>\% 
  nest(data = -continent) \%>\%
  nest_group_by(data, country) \%>\%
  nest_filter(data, pop > mean(pop, na.rm = TRUE))
}

In the ungrouped version, \code{nest_filter()} compares the value of \code{pop} in each
row to the global average in \code{.nest_data}, keeping only the rows with \code{pop}
greater than this global average. In contrast, the grouped version calculates
the average population separately for each \code{country} group within \code{.nest_data}, and
keeps rows with \code{pop} greater than the relevant within-country average.
}

\examples{
\dontrun{
library(tidyverse)
library(gapminder)

# create nested tibble for use in examples
gapminder_nested <-
  gapminder \%>\%
  nest(country_data = -continent)

# filter by one criterion 
gapminder_nested \%>\% nest_filter(country_data, year == 1992)
gapminder_nested \%>\% nest_filter(country_data, pop < 10000000)

# filtering by multiple criteria within a single logical expression
gapminder_nested \%>\% nest_filter(country_data, year > 1990 & lifeExp < 40)
gapminder_nested \%>\% nest_filter(country_data, lifeExp > 40 | gdpPercap > 900)

# when multiple expressions are used, they are combined using &
gapminder_nested \%>\% nest_filter(country_data, year == 1992, pop < 10000000)

# filtering may yield different results on grouped tibbles 
# because the expressions are computed within groups within `.nest_data`.

# the following filters rows where `pop` is greater than the 
# global average within `.nest_data`.
gapminder_nested \%>\% 
  nest_filter(country_data, pop > mean(pop, na.rm = TRUE))

# whereas this keeps rows within greater than the 
# country average within `.nest_data`.
gapminder_nested \%>\% 
  nest_group_by(country_data, country) \%>\% 
  nest_filter(country_ata, pop > mean(pop, na.rm = TRUE))
}
}
