% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nest_group-by.R
\name{nest_group_by}
\alias{nest_group_by}
\alias{nest_ungroup}
\title{Group a nested object by one or more variables}
\usage{
nest_group_by(.data, .nest_data, ..., .add = FALSE, .drop = TRUE)

nest_ungroup(.data, .nest_data, ...)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a lazy
lazy data frame (e.g. from dbplyr or dtplyr).}

\item{.nest_data}{A list-col containing data frames (or tibbles).}

\item{...}{In \code{nest_group_by()}, variables or computations to group by.
Computations are always done on the ungrouped data frames.
To perform computations on grouped data, you need to use a separate
\code{nest_mutate()} step before the \code{nest_group_by()}.
In \code{nest_ungroup()}, variables to remove from the grouping.}

\item{.add}{When \code{FALSE}, the default, \code{nest_group_by()} will override
existing groups. To add to the existing groups, use \code{.add = TRUE}.}

\item{.drop}{Drop groups formed by factor levels that don't appear in the
data? Defaults to \code{TRUE}.

Unlike the equivalent parameter in \code{dplyr::group_by()}, \code{.drop} in
\code{nest_group_by()} does not automatically infer whether or not the data was
previously grouped with \code{.drop = FALSE}, meaning you will need to
explicitly set \code{.drop = FALSE} for a sequence of groupings.

For more information, please see \code{dplyr::group_by()} and
\code{dplyr::group_by_drop_default()}}
}
\value{
A tibble or dataframe where \code{.nest_data} is a list-col of grouped
data frames with class \code{group_df}, unless the combination of \code{...} and
\code{.add} yields an empty set of grouping columns, in which case \code{.nest_data}
will be a list-col of tibbles.
}
\description{
Most data operations are done on groups defined by variables.
\code{nest_group_by()} takes an existing list-col of tbls and converts it into a
list-col of grouped tbls where operations are performed "by group".
\code{nest_ungroup()} removes grouping.
}
\examples{
gapminder_grouped <-
  gapminder::gapminder \%>\%
  tidyr::nest(country_data = -continent) \%>\%
  nest_group_by(country_data, year)
  
# grouping doesn't change the structure of .data, apart from listing
# the class in .nest_data as grouped_df.
gapminder_grouped

# It changes how it acts with other nplyr verbs:
gapminder_grouped \%>\%
  nest_summarise(country_data, 
                 pop = mean(pop), 
                 lifeExp = mean(lifeExp))

gapminder_grouped \%>\%
  nest_filter(country_data, pop == max(pop))
  
# to remove grouping, use nest_ungroup
gapminder_grouped \%>\%
  nest_ungroup(country_data)
  
# By default, nest_group_by() overrides existing grouping
gapminder_grouped \%>\%
  nest_group_by(country_data, country) \%>\%
  mutate(groups = purrr::map(country_data, group_vars))

# Use .add = TRUE to instead append
gapminder_grouped \%>\%
  nest_group_by(country_data, country, .add = TRUE) \%>\%
  mutate(groups = purrr::map(country_data, group_vars))
  
gapminder_nested <-
  gapminder::gapminder \%>\%
  tidyr::nest(country_data = -continent)
  
# You can group by expressions: this is a short-hand 
# for a nest_mutate() followed by a nest_group_by()
gapminder_nested \%>\%
  nest_group_by(pop = round(pop, -6)) \%>\%
  mutate(n_groups = purrr::map_int(country_data, n_groups))

# The implicit mutate() step is always performed on the 
# ungrouped nested data. Here we get 3 groups in each nested tbl:
gapminder_nested \%>\%
  nest_group_by(pop_cut = cut(pop, 3)) \%>\%
  mutate(n_groups = purrr::map_int(country_data, n_groups))

# If you want it to be performed by groups,
# you have to use an explicit nest_mutate() call. 
# Here we get 3 groups per country in each nested tbl.
gapminder_nested \%>\%
  nest_group_by(country_data, country) \%>\%
  nest_mutate(country_data, pop_cut = cut(pop, 3)) \%>\%
  nest_group_by(pop_cut) \%>\%
  mutate(n_groups = purrr::map_int(country_data, n_groups))
}
\concept{grouping functions}
